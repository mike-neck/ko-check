*Ktcheck*'s dependency graph is shown below.

[plantuml]
----
@startuml
[user-program] as user

[ktcheck] as kc
[ktcheck-api] as api
[ktcheck-assertion] as ast
[ktcheck-engine] as eng
[junit-platform-engine] as jen
[opentest4j] as open

user --> kc : implementation

kc -> ast : api
kc --> api : api
kc --> eng : implementation

ast --> api : implementation

api --> open : implementation

eng -> api : implementation
eng --> jen : implementation
eng --> open : implementation
@enduml
----

* `ktcheck-api` is a main core library that defines *ktcheck*'s API for users to write tests.
* `ktcheck-assertion` is a assertion library for users to convert user's assertions into *ktcheck* API(`Assertion`).
* `ktcheck-engine` is an implementation of JUnit Jupiter engine which enables *ktcheck* to run on JUnit platform.
* `ktcheck` is a facade artifact, which refers `ktcheck-api` and `ktcheck-assertion` as API dependency, `ktcheck-engine` as runtime dependency.

=== Installation via Maven/Gradle

==== 1. Running *ktcheck* on JUnit Platform.

Add `ktcheck` to your project. Then enable JUnit platform test.

.pom.xml
[source,xml]
----
<dependency>
  <groupId>run.ktcheck</groupId>
  <artifactId>ktcheck</artifactId>
  <version>v0.1.0</version>
  <scope>test</scope>
</dependency>
----

.build.gradle
[source,groovy]
----
dependencies {
  testImplementation 'run.ktcheck:ktcheck:v0.1.0'
}

test {
  useJUnitPlatform()
}
----

.build.gradle.kts
[source,kotlin]
----
dependencies {
  testImplementation("run.ktcheck:ktcheck:v0.1.0")
}

tasks {
  "test"(Test::class) {
    useJUnitPlatform()
  }
}
----

==== 2. Running *ktcheck* standalone.

Add `ktcheck-api` and `ktcheck-assertion` to your project.

.pom.xml
[source,xml]
----
<dependencies>
  <dependency>
    <groupId>run.ktcheck</groupId>
    <artifactId>ktcheck-api</artifactId>
    <version>v0.1.0</version>
    <scope>test</scope>
  </dependency>
  <dependency>
    <groupId>run.ktcheck</groupId>
    <artifactId>ktcheck-assertion</artifactId>
    <version>v0.1.0</version>
    <scope>test</scope>
  </dependency>
</dependencies>
----

.build.gradle
[source,groovy]
----
dependencies {
  testImplementation 'run.ktcheck:ktcheck-api:v0.1.0'
}
----

.build.gradle.kts
[source,kotlin]
----
dependencies {
  testImplementation("run.ktcheck:ktcheck-api:v0.1.0")
  testImplementation("run.ktcheck:ktcheck-assertion:v0.1.0")
}
----

=== Writing Tests

We are using the models bellow through this section.

.Class under test
[source,kotlin]
----
class Greeting(
  private val text: String
) {
  operator fun invoke(person: String): String = "$text, ${person}."
}
----

==== `KtCheck` interface

*Ktcheck*'s interface which represents the test is `KtCheck`. So import it into your test class,
then create an object which implements `KtCheck`.
Please note that *ktcheck* won't pick up classes at all.

.`GreetingTest.kt`
[source,kotlin]
----
import run.ktcheck.KtCheck

object GreetingTest: KtCheck
----

==== `Given`

The interface `KtCheck` defines only one property `all: Iterable<KtProperty>`, but you do not need to implement it by hand.
*Ktcheck* provides its implementation class `Given`.
Create a `Given` instance, and pass it to `GreetingTest` via `by`, so that the test object can implement `KtCheck` by delegating to the `Given` instance.
The constructor of the class `Given` takes a function which prepares pre-condition of function execution to be tested.
In our example case, the function returns a `Greeting` instance which holds `"hello"` at its `text` property.

.`GreetingTest.kt`
[source,kotlin]
----
import run.ktcheck.Given
import run.ktcheck.KtCheck

object GreetingTest: KtCheck
by Given({ Greeting("Hello") })
----

[NOTE]
====
In `Give` function, write pre-condition of the object/function under test.
====

==== `When` 

We will invoke the target function `Greeting#invoke` in a function given to the constructor of `When`.
The `When` function has a parameter which is generated by `Given` function, and returns a result of invocation of the target function under test.

.`GreetingTest.kt`
[source,kotlin]
----
import run.ktcheck.Given
import run.ktcheck.KtCheck

object GreetingTest: KtCheck
by Given({ Greeting("Hello") })
  .When({ greeting -> greeting.invoke("Kotlin") })
----

[NOTE]
====
In `When` function, invoke the object's function under test.
====

==== `Then`

The tests result depends on assertion or verification of a result got by an invocation of function under test.
So our test should do it via assertion function given to `Then`.

The assertion function will be given two parameters.
The first is the object generated by `Given` pre-condition function,
the later is the object returned by `When` invoking function.

*Ktcheck* expects the assertion function to return an assertion result into type of `Assertion`. 
The `Assertion` is an interface with three abstract functions, but you don't need to implement it manually,
because *ktcheck-assertion* provides utility functions.


.`GreetingTest.kt`
[source,kotlin]
----
import run.ktcheck.Given
import run.ktcheck.KtCheck
import run.ktcheck.assertion.NoDep.shouldBe


object GreetingTest: KtCheck
by Given({ Greeting("Hello") })
  .When({ greeting -> greeting.invoke("Kotlin") })
  .Then({ _, greetingText -> greetingText shouldBe "Hello, Kotlin." })
----

[NOTE]
====
In `Then` function, assert/verify the post-condition of the target function invocation.
====


=== Running Tests

Now we have finished writing our tests, then let's run them. *Ktcheck* provides two ways to run the tests.

* Running standalone.
* Running on JUnit platform.

==== Running standalone

*Ktcheck* provides the way to run tests standalone. `KtCheck`'s function `runStandalone` is the way.
Using this function, you can run *ktcheck* on any testing framework, such as JUnit vintage, JUnit Jupiter, kotest... etc.
The function is `KtCheck`'s default function, so that you can easily call it, without implementing any classes other than JUnit Jupiter's test classes.

Here is an example of running `GreetingTest` standalone on JUnit Jupiter.

.`GreetingTest.kt`
[source,kotlin]
----
import run.ktcheck.Given
import run.ktcheck.KtCheck
import run.ktcheck.assertion.NoDep.shouldBe
import org.junit.jupiter.api.Test

object GreetingTest: KtCheck
by Given({ Greeting("Hello") })
  .When({ greeting -> greeting.invoke("Kotlin") })
  .Then({ _, greetingText -> greetingText shouldBe "Hello, Kotlin." })

class RunGreetingTest {
  @Test
  fun runGreeting() {
    GreetingTest.runStandalone()
  }
}
----

==== Running on JUnit platform

Running on JUnit platform is the easiest way to run all tests, because *ktcheck* engine detects all the test for you.

.Running *ktcheck* with gradle
[source,shell-session]
----
$ ./gradlew test

> Task :ktcheck-example:compileKotlin NO-SOURCE
> Task :ktcheck-example:compileJava NO-SOURCE
> Task :ktcheck-example:processResources NO-SOURCE
> Task :ktcheck-example:classes UP-TO-DATE
> Task :ktcheck-example:compileTestKotlin
> Task :ktcheck-example:compileTestJava NO-SOURCE
> Task :ktcheck-example:processTestResources NO-SOURCE
> Task :ktcheck-example:testClasses UP-TO-DATE
> Task :ktcheck-example:test
BUILD SUCCESSFUL in 2s
9 actionable tasks: 9 executed
23:23:45: Task execution finished 'test'.
----

If there are failed tests, its log becomes like this.

.If some tests failed
[source, shell-session]
----
org.opentest4j.AssertionFailedError: test failed - Given With callbacks, When add an item, Then the size is 6

Test failed. Given@3371dd73-1,Given With callbacks, When add an item, Then the size is 6

expected: 6
actual  : 5

Given With callbacks:  run.ktcheck.example4.WithCallbacks$4$1@6011152a
When add an item:  [foo, bar, baz, qux, quux]
Then the size is 6
----

*Ktcheck* engine is one of implementations of JUnit Platform engine, *ktcheck* can be run in conjunction with another JUnit platform engines like
JUnit Jupiter engine, JUnit vintage engine, kotest engine... etc. For more information on JUnit platform engine, please see https://junit.org/junit5/docs/current/user-guide/[JUnit5 User guide].
